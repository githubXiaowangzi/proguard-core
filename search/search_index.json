{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"ProGuardCORE is a free library to read, analyze, modify, and write Java class files. It is the core of the well-known shrinker, optimizer, and obfuscator ProGuard and of the ProGuard Assembler and Disassembler . Typical applications: Perform peephole optimizations in Java bytecode. Search for instruction patterns. Analyze code with abstract evaluation. Optimize and obfuscate, like ProGuard itself. Design The library defines many small classes as the building blocks for applications that contain the processing logic. This is sometimes taken to the extreme: even loops and conditional statements can often be implemented as separate classes. Even though these classes are verbose and repetitive, the resulting main code becomes much more compact, flexible, and robust. Data classes Basic data classes define the structures to represent Java bytecode. They reflect the Java bytecode specifications literally, to ensure that no data are lost when reading, analyzing, and writing them. The data classes contain only a minimum number of methods. They do have one or more accept methods to let the visitor classes below operate on them. Visitor classes The library applies the visitor pattern extensively. Visitor classes define the operations on the data: reading, writing, editing, transforming, analyzing, etc. The visitor classes have one or more 'visit' methods to operate on data classes of the same basic type. For example, a Java bytecode class contains a constant pool with constants of different types: integer constants, float constants, string constants, etc. The data classes IntegerConstant, FloatConstant, StringConstant, etc. all implement the basic type Constant. The visitor interface ConstantVisitor contains methods 'visitIntegerConstant', 'visitFloatConstant', 'visitStringConstant', etc. Implementations of this visitor interface can perform all kinds of operations on the constants. The reasoning behind this pattern is that the data classes are very stable, because they are directly based on the bytecode specifications. The operations are more dynamic, since they depend on the final application. It is practically impossible to add all possible operations in the data classes, but it is easy to add another implementation of a visitor interface. Implementing an interface in practice helps a lot to think of all possible cases. The visitor pattern uses visitor interfaces to operate on the similar elements of a data structure. Each interface often has many implementations. A great disadvantage at this time is that visitor methods can invoke one another (directly or indirectly), but they can't communicate easily. Since the implementations can't add their own parameters or return values, they often have to rely on fields to pass values back and forth. This is more error-prone. Still, the advantages of the visitor pattern outweigh the disadvantages. Dependency injection The library classes heavily use constructor-based dependency injection , to create immutable instances. Notably the visitor classess are often like commands that are combined in an immutable structure, via constructors. You can execute such commands by applying the visitors to the data classes. API You can find the complete API in the ProGuardCORE javadoc .","title":"Introduction"},{"location":"index.html#design","text":"The library defines many small classes as the building blocks for applications that contain the processing logic. This is sometimes taken to the extreme: even loops and conditional statements can often be implemented as separate classes. Even though these classes are verbose and repetitive, the resulting main code becomes much more compact, flexible, and robust.","title":"Design"},{"location":"index.html#data-classes","text":"Basic data classes define the structures to represent Java bytecode. They reflect the Java bytecode specifications literally, to ensure that no data are lost when reading, analyzing, and writing them. The data classes contain only a minimum number of methods. They do have one or more accept methods to let the visitor classes below operate on them.","title":"Data classes"},{"location":"index.html#visitor-classes","text":"The library applies the visitor pattern extensively. Visitor classes define the operations on the data: reading, writing, editing, transforming, analyzing, etc. The visitor classes have one or more 'visit' methods to operate on data classes of the same basic type. For example, a Java bytecode class contains a constant pool with constants of different types: integer constants, float constants, string constants, etc. The data classes IntegerConstant, FloatConstant, StringConstant, etc. all implement the basic type Constant. The visitor interface ConstantVisitor contains methods 'visitIntegerConstant', 'visitFloatConstant', 'visitStringConstant', etc. Implementations of this visitor interface can perform all kinds of operations on the constants. The reasoning behind this pattern is that the data classes are very stable, because they are directly based on the bytecode specifications. The operations are more dynamic, since they depend on the final application. It is practically impossible to add all possible operations in the data classes, but it is easy to add another implementation of a visitor interface. Implementing an interface in practice helps a lot to think of all possible cases. The visitor pattern uses visitor interfaces to operate on the similar elements of a data structure. Each interface often has many implementations. A great disadvantage at this time is that visitor methods can invoke one another (directly or indirectly), but they can't communicate easily. Since the implementations can't add their own parameters or return values, they often have to rely on fields to pass values back and forth. This is more error-prone. Still, the advantages of the visitor pattern outweigh the disadvantages.","title":"Visitor classes"},{"location":"index.html#dependency-injection","text":"The library classes heavily use constructor-based dependency injection , to create immutable instances. Notably the visitor classess are often like commands that are combined in an immutable structure, via constructors. You can execute such commands by applying the visitors to the data classes.","title":"Dependency injection"},{"location":"index.html#api","text":"You can find the complete API in the ProGuardCORE javadoc .","title":"API"},{"location":"analyzing.html","text":"Analyzing all instructions If you want to analyze bytecode, you'll probably want to visit specified instructions of specified code attributes of specified methods of specified classes. The visitor classes and filters quickly get you to the right place: programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new AllInstructionVisitor ( new MyInstructionAnalyzer ())))); You then only need to implement the visitor methods to analyze the instructions: class MyInstructionAnalyzer implements InstructionVisitor { public void visitSimpleInstruction ( Clazz clazz , .....) ... public void visitVariableInstruction ( Clazz clazz , .....) ... public void visitConstantInstruction ( Clazz clazz , .....) ... public void visitBranchInstruction ( Clazz clazz , .....) ... public void visitTableSwitchInstruction ( Clazz clazz , .....) ... public void visitLookUpSwitchInstruction ( Clazz clazz , .....) ... } The library already provides classes to analyze the code for you, finding branching information, performing partial evaluation, finding the control flow and data flow, etc, as introduced in the following sections. Complete example: EvaluateReturnValues.java Collecting basic branching information You can extract basic information about branches in a method with the class BranchTargetFinder. The results are defined at the instruction level: each instruction is properly labeled as a branch target, branch origin, exception handler, etc. BranchTargetFinder branchTargetFinder = new BranchTargetFinder (); branchTargetFinder . visitCodeAttribute ( clazz , method , codeAttribute ); if ( branchTargetFinder . isBranchOrigin ( offset )) ... if ( branchTargetFinder . isBranchTarget ( offset )) ... Complete example: ApplyPeepholeOptimizations.java Partial evaluation You can extract more information about the code with partial evaluation (often called abstract evaluation or symbolic evaluation). Its analysis provides a global view of the control flow and data flow in a method. The core class is PartialEvaluator. It can work at different levels of precision \u2014 the more abstract, the less precise. You can control the precision with different value factories and different invocation units: A ValueFactory defines the level of detail in representing values like integers or reference types. The values can be very abstract (any primitive integer, a reference to any object) or more precise (the integer 42, or an integer between 0 and 5, or a non-null reference to an instance of java/lang/String). An InvocationUnit defines the values returned from retrieved fields and invoked methods. The values can again be very generic (any integer) or they can also be values that were cached in prior evaluations of the code base. Complete example: EvaluateCode.java, which provides options to analyze code with different levels of precision. It prints out its results in markdown format, which is also used in the examples below. Control flow analysis You can set up basic evaluation with a BasicValueFactory and a BasicInvocationUnit: ValueFactory valueFactory = new BasicValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The analysis provides a control flow graph of the instructions in a method. Each instruction is labeled with potential branch targets and branch origins: InstructionOffsetValue branchOrigins = partialEvaluator . branchOrigins ( offset )); InstructionOffsetValue branchTargets = partialEvaluator . branchTargets ( offset )); Complete example: VisualizeControlFlow.java Data flow analysis You can also insprect the data flow between the instructions in a method by looking at the stack and the local variables: TracedStack stack = partialEvaluator . getStackAfter ( offset ); TracedVariables variables = partialEvaluator . getVariablesAfter ( offset ); Consider the following code: public static int getAnswer () { int f1 = 6 ; int f2 = 7 ; return f1 * f2 ; } Applying the above partial evaluator to this code yields this overall result: Instruction Stack v0 v1 [0] bipush 6 [0:i] empty empty [2] istore_0 v0 2:i empty [3] bipush 7 [3:i] 2:i empty [5] istore_1 v1 2:i 5:i [6] iload_0 v0 [6:i] 2:i 5:i [7] iload_1 v1 [6:i] [7:i] 2:i 5:i [8] imul [8:i] 2:i 5:i [9] ireturn 2:i 5:i Each integer value followed by a colon indicates the offset of the instruction that stored or pushed the value. Each 'i' indicates an unknown primitive integer value. Useful applications: dependency analysis at an instruction level, for example to remove unused instructions. Complete example: EvaluateCode.java More precise numerical evaluation The above basic evaluation doesn't tell you much about any numerical results. You can set up more precise numerical evaluation with a ParticularValueFactory: ValueFactory valueFactory = new ParticularValueFactory ( new BasicValueFactory ()); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); For the same code as in the previous section: Instruction Stack v0 v1 [0] bipush 6 [0:6] empty empty [2] istore_0 v0 2:6 empty [3] bipush 7 [3:7] 2:6 empty [5] istore_1 v1 2:6 5:7 [6] iload_0 v0 [6:6] 2:6 5:7 [7] iload_1 v1 [6:6] [7:7] 2:6 5:7 [8] imul [8:42] 2:6 5:7 [9] ireturn 2:6 5:7 In this trivial example, the previously unknown integers are now all concrete values. The last instruction pops the computed result 42 from the stack and returns it. Useful application: constant propagation. Evaluation with numeric ranges Consider the following code: public static int getAnswer () { int answer = 0 ; for ( int counter = 0 ; counter < 3 && Math . random () < 0.5f ; counter ++ ) { answer += 14 ; } return answer ; } The possible answer isn't a single value. You can let the evaluation work with integer ranges with a RangeValueFactory: ValueFactory valueFactory = new RangeValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The overall result of the analysis of the sample method is: Instruction Stack v0 v1 [0] iconst_0 [0:0] empty empty [1] istore_0 v0 1:0 empty [2] iconst_0 [2:0] 1:0 empty [3] istore_1 v1 1:0 3:0 [4] iload_1 v1 [4:0..3] 1,19:0..42 3,22:0..3 [5] iconst_3 [4:0..3] [5:3] 1,19:0..42 3,22:0..3 [6] if_icmpge +22 (target=28) 1,19:0..42 3,22:0..3 [9] invokestatic #2 [9:T] [9:d] 1,19:0..28 3,22:0..2 [12] ldc2_w #3 [9:T] [9:d] [12:T] [12:0.5d] 1,19:0..28 3,22:0..2 [15] dcmpg [15:i] 1,19:0..28 3,22:0..2 [16] ifge +12 (target=28) 1,19:0..28 3,22:0..2 [19] iinc v0, 14 19:14..42 3,22:0..2 [22] iinc v1, 1 19:14..42 22:1..3 [25] goto -21 (target=4) 19:14..42 22:1..3 [28] iload_0 v0 [28:0..42] 1,19:0..42 3,22:0..3 [29] ireturn 1,19:0..42 3,22:0..3 Not all values are entirely concrete; they can have a range (with \"..\"). The method can return a value between 0 and 42. Useful applications: simplification of range checks. Symbolic numerical evaluation Consider the following code: private static int getAnswer ( int a , int b ) { return 2 * a + b ; } The numerical evaluation of the previous sections doesn't get you very far, since the parameters are unknown, so all computations produce unknown values: Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i P1:i [1] iload_0 v0 [0:2] [1:i] P0:i P1:i [2] imul [2:i] P0:i P1:i [3] iload_1 v1 [2:i] [3:i] P0:i P1:i [4] iadd [4:i] P0:i P1:i [5] ireturn P0:i P1:i You can set up symbolic evaluation with an IdentifiedValueFactory: ValueFactory valueFactory = new IdentifiedValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The overall result of the analysis of the sample method is: Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i0 P1:i1 [1] iload_0 v0 [0:2] [1:i0] P0:i0 P1:i1 [2] imul [2:(2*i0)] P0:i0 P1:i1 [3] iload_1 v1 [2:(2*i0)] [3:i1] P0:i0 P1:i1 [4] iadd [4:((2*i0)+i1)] P0:i0 P1:i1 [5] ireturn P0:i0 P1:i1 The unknown values now have symbolic names (IDs): \"i0\" and \"i1\". Any computations result in symbolic expressions, such as \"((2*i0)+i1)\". Useful applications: a basis for symbolic simplification, static single assignment, further analysis with SMT solvers (satisfiability modulo theories). Evaluation with reference types The previous sections only showed examples with primitive types. Consider the following code with reference types: public static Number getAnswer ( Number answer ) { if ( answer == null ) { answer = new Integer ( 42 ); } return answer ; } The basic or numeric evaluation of the previuous sections don't tell much about the non-primitive types: Instruction Stack v0 [0] aload_0 v0 [0:a] P0:a [1] ifnonnull +13 (target=14) P0:a [4] new #2 [4:a] P0:a [7] dup [4:7:a] [4:7:a] P0:a [8] bipush 42 [4:7:a] [4:7:a] [8:42] P0:a [10] invokespecial #3 [4:7:a] P0:a [13] astore_0 v0 13:a [14] aload_0 v0 [14:a] P0,13:a [15] areturn P0,13:a Unknown reference types are shown as \"a\". You can keep track of origins of references in more detail with a ReferenceTracingValueFactory and a ReferenceTracingInvocationUnit. The PartialEvaluator is set up slightly differently from the earlier examples: ReferenceTracingValueFactory valueFactory = new ReferenceTracingValueFactory ( new BasicValueFactory ()) : InvocationUnit invocationUnit = new ReferenceTracingInvocationUnit ( new BasicInvocationUnit ( valueFactory )); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false , valueFactory ); The results then show the origins of non-primitive types: Instruction Stack v0 [0] aload_0 v0 [0:P0:a] P0:P0:a [1] ifnonnull +13 (target=14) P0:P0:a [4] new #2 [4:N4:a] P0:P0:a [7] dup [4:7:N4:a] [4:7:N4:a] P0:P0:a [8] bipush 42 [4:7:N4:a] [4:7:N4:a] [8:i] P0:P0:a [10] invokespecial #3 [4:7:N4:a] P0:P0:a [13] astore_0 v0 13:N4:a [14] aload_0 v0 [14:N4,P0:a] P0,13:N4,P0:a [15] areturn P0,13:N4,P0:a For example, the method pops and returns either a new instance (\"N4\") that was created at offset 4, or parameter 0 (\"P0\"). Useful applications: define/use analysis, a basis for escape analysis or taint analysis. Evaluation with more precise reference types You can keep track of non-primitive types in more detail with a TypedReferenceValueFactory: ValueFactory valueFactory = new TypedReferenceValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results then show the types: Instruction Stack v0 [0] aload_0 v0 [0:java/lang/Number] P0:java/lang/Number [1] ifnonnull +13 (target=14) P0:java/lang/Number [4] new #2 [4:java/lang/Integer=!] P0:java/lang/Number [7] dup [4:7:java/lang/Integer=!] [4:7:java/lang/Integer=!] P0:java/lang/Number [8] bipush 42 [4:7:java/lang/Integer=!] [4:7:java/lang/Integer=!] [8:i] P0:java/lang/Number [10] invokespecial #3 [4:7:java/lang/Integer=!] P0:java/lang/Number [13] astore_0 v0 13:java/lang/Integer=! [14] aload_0 v0 [14:java/lang/Number] P0,13:java/lang/Number [15] areturn P0,13:java/lang/Number The types here are \"java/lang/Number\" and \"java/lang/Integer\". The types respect the type hierarchy, for example when the branches join and the type is \"java/lang/Number\". A mark \"=\" means that the type is the exact type, not an extension. A mark \"!\" means that the value is definitely not null. Useful applications: preverification of the type safety of bytecode. Evaluation with primitive arrays Primitive arrays may be of special interest, for example when performing optimizations. Consider the following code: public static int getAnswer () { int [] array = new int [] { 6 , 7 }; return array [ 0 ] * array [ 1 ] ; } Even though this is a trivial example, the previous evaluations wouldn't provide much useful information: Instruction Stack v0 [0] iconst_2 [0:i] empty [1] newarray 10 [1:[I?=![i]] empty [3] dup [1:3:[I?=![i]] [1:3:[I?=![i]] empty [4] iconst_0 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] empty [5] bipush 6 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] [5:i] empty [7] iastore [1:3:[I?=![i]] empty [8] dup [1:8:[I?=![i]] [1:8:[I?=![i]] empty [9] iconst_1 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] empty [10] bipush 7 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] [10:i] empty [12] iastore [1:8:[I?=![i]] empty [13] astore_0 v0 13:[I?=![i] [14] aload_0 v0 [14:[I?=![i]] 13:[I?=![i] [15] iconst_0 [14:[I?=![i]] [15:i] 13:[I?=![i] [16] iaload [16:i] 13:[I?=![i] [17] aload_0 v0 [16:i] [17:[I?=![i]] 13:[I?=![i] [18] iconst_1 [16:i] [17:[I?=![i]] [18:i] 13:[I?=![i] [19] iaload [16:i] [19:i] 13:[I?=![i] [20] imul [20:i] 13:[I?=![i] [21] ireturn 13:[I?=![i] The array type is \"[I\", which is the standard notation for an array of primitive integers. You can keep track of the lengths of arrays with ArrayReferenceValueFactory and even of the contents of primitive arrays with DetailedArrayValueFactory: ValueFactory valueFactory = new DetailedArrayValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results of the evaluation then become: Instruction Stack v0 [0] iconst_2 [0:2] empty [1] newarray 10 [1:[I?=![2]#0 empty [3] dup [1:3:[I?=![2]#0 empty [4] iconst_0 [1:3:[I?=![2]#0 empty [5] bipush 6 [1:3:[I?=![2]#0 empty [7] iastore [1:3:[I?=![2]#0 empty [8] dup [1:8:[I?=![2]#0 empty [9] iconst_1 [1:8:[I?=![2]#0 empty [10] bipush 7 [1:8:[I?=![2]#0 empty [12] iastore [1:8:[I?=![2]#0 empty [13] astore_0 v0 13:[I?=![2]#0 [14] aload_0 v0 [14:[I?=![2]#0 13:[I?=![2]#0 [15] iconst_0 [14:[I?=![2]#0 13:[I?=![2]#0 [16] iaload [16:6] 13:[I?=![2]#0 [17] aload_0 v0 [16:6] [17:[I?=![2]#0 13:[I?=![2]#0 [18] iconst_1 [16:6] [17:[I?=![2]#0 13:[I?=![2]#0 [19] iaload [16:6] [19:7] 13:[I?=![2]#0 [20] imul [20:42] 13:[I?=![2]#0 [21] ireturn 13:[I?=![2]#0 The array is now traced as having length 2 and elements 6 and 7. Useful application: simplification of code with enum types.","title":"Analyzing code"},{"location":"analyzing.html#analyzing-all-instructions","text":"If you want to analyze bytecode, you'll probably want to visit specified instructions of specified code attributes of specified methods of specified classes. The visitor classes and filters quickly get you to the right place: programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new AllInstructionVisitor ( new MyInstructionAnalyzer ())))); You then only need to implement the visitor methods to analyze the instructions: class MyInstructionAnalyzer implements InstructionVisitor { public void visitSimpleInstruction ( Clazz clazz , .....) ... public void visitVariableInstruction ( Clazz clazz , .....) ... public void visitConstantInstruction ( Clazz clazz , .....) ... public void visitBranchInstruction ( Clazz clazz , .....) ... public void visitTableSwitchInstruction ( Clazz clazz , .....) ... public void visitLookUpSwitchInstruction ( Clazz clazz , .....) ... } The library already provides classes to analyze the code for you, finding branching information, performing partial evaluation, finding the control flow and data flow, etc, as introduced in the following sections. Complete example: EvaluateReturnValues.java","title":"Analyzing all instructions"},{"location":"analyzing.html#branching","text":"You can extract basic information about branches in a method with the class BranchTargetFinder. The results are defined at the instruction level: each instruction is properly labeled as a branch target, branch origin, exception handler, etc. BranchTargetFinder branchTargetFinder = new BranchTargetFinder (); branchTargetFinder . visitCodeAttribute ( clazz , method , codeAttribute ); if ( branchTargetFinder . isBranchOrigin ( offset )) ... if ( branchTargetFinder . isBranchTarget ( offset )) ... Complete example: ApplyPeepholeOptimizations.java","title":"Collecting basic branching information"},{"location":"analyzing.html#partial-evaluation","text":"You can extract more information about the code with partial evaluation (often called abstract evaluation or symbolic evaluation). Its analysis provides a global view of the control flow and data flow in a method. The core class is PartialEvaluator. It can work at different levels of precision \u2014 the more abstract, the less precise. You can control the precision with different value factories and different invocation units: A ValueFactory defines the level of detail in representing values like integers or reference types. The values can be very abstract (any primitive integer, a reference to any object) or more precise (the integer 42, or an integer between 0 and 5, or a non-null reference to an instance of java/lang/String). An InvocationUnit defines the values returned from retrieved fields and invoked methods. The values can again be very generic (any integer) or they can also be values that were cached in prior evaluations of the code base. Complete example: EvaluateCode.java, which provides options to analyze code with different levels of precision. It prints out its results in markdown format, which is also used in the examples below.","title":"Partial evaluation"},{"location":"analyzing.html#control-flow-analysis","text":"You can set up basic evaluation with a BasicValueFactory and a BasicInvocationUnit: ValueFactory valueFactory = new BasicValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The analysis provides a control flow graph of the instructions in a method. Each instruction is labeled with potential branch targets and branch origins: InstructionOffsetValue branchOrigins = partialEvaluator . branchOrigins ( offset )); InstructionOffsetValue branchTargets = partialEvaluator . branchTargets ( offset )); Complete example: VisualizeControlFlow.java","title":"Control flow analysis"},{"location":"analyzing.html#data-flow-analysis","text":"You can also insprect the data flow between the instructions in a method by looking at the stack and the local variables: TracedStack stack = partialEvaluator . getStackAfter ( offset ); TracedVariables variables = partialEvaluator . getVariablesAfter ( offset ); Consider the following code: public static int getAnswer () { int f1 = 6 ; int f2 = 7 ; return f1 * f2 ; } Applying the above partial evaluator to this code yields this overall result: Instruction Stack v0 v1 [0] bipush 6 [0:i] empty empty [2] istore_0 v0 2:i empty [3] bipush 7 [3:i] 2:i empty [5] istore_1 v1 2:i 5:i [6] iload_0 v0 [6:i] 2:i 5:i [7] iload_1 v1 [6:i] [7:i] 2:i 5:i [8] imul [8:i] 2:i 5:i [9] ireturn 2:i 5:i Each integer value followed by a colon indicates the offset of the instruction that stored or pushed the value. Each 'i' indicates an unknown primitive integer value. Useful applications: dependency analysis at an instruction level, for example to remove unused instructions. Complete example: EvaluateCode.java","title":"Data flow analysis"},{"location":"analyzing.html#numerical","text":"The above basic evaluation doesn't tell you much about any numerical results. You can set up more precise numerical evaluation with a ParticularValueFactory: ValueFactory valueFactory = new ParticularValueFactory ( new BasicValueFactory ()); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); For the same code as in the previous section: Instruction Stack v0 v1 [0] bipush 6 [0:6] empty empty [2] istore_0 v0 2:6 empty [3] bipush 7 [3:7] 2:6 empty [5] istore_1 v1 2:6 5:7 [6] iload_0 v0 [6:6] 2:6 5:7 [7] iload_1 v1 [6:6] [7:7] 2:6 5:7 [8] imul [8:42] 2:6 5:7 [9] ireturn 2:6 5:7 In this trivial example, the previously unknown integers are now all concrete values. The last instruction pops the computed result 42 from the stack and returns it. Useful application: constant propagation.","title":"More precise numerical evaluation"},{"location":"analyzing.html#range","text":"Consider the following code: public static int getAnswer () { int answer = 0 ; for ( int counter = 0 ; counter < 3 && Math . random () < 0.5f ; counter ++ ) { answer += 14 ; } return answer ; } The possible answer isn't a single value. You can let the evaluation work with integer ranges with a RangeValueFactory: ValueFactory valueFactory = new RangeValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The overall result of the analysis of the sample method is: Instruction Stack v0 v1 [0] iconst_0 [0:0] empty empty [1] istore_0 v0 1:0 empty [2] iconst_0 [2:0] 1:0 empty [3] istore_1 v1 1:0 3:0 [4] iload_1 v1 [4:0..3] 1,19:0..42 3,22:0..3 [5] iconst_3 [4:0..3] [5:3] 1,19:0..42 3,22:0..3 [6] if_icmpge +22 (target=28) 1,19:0..42 3,22:0..3 [9] invokestatic #2 [9:T] [9:d] 1,19:0..28 3,22:0..2 [12] ldc2_w #3 [9:T] [9:d] [12:T] [12:0.5d] 1,19:0..28 3,22:0..2 [15] dcmpg [15:i] 1,19:0..28 3,22:0..2 [16] ifge +12 (target=28) 1,19:0..28 3,22:0..2 [19] iinc v0, 14 19:14..42 3,22:0..2 [22] iinc v1, 1 19:14..42 22:1..3 [25] goto -21 (target=4) 19:14..42 22:1..3 [28] iload_0 v0 [28:0..42] 1,19:0..42 3,22:0..3 [29] ireturn 1,19:0..42 3,22:0..3 Not all values are entirely concrete; they can have a range (with \"..\"). The method can return a value between 0 and 42. Useful applications: simplification of range checks.","title":"Evaluation with numeric ranges"},{"location":"analyzing.html#symbolic","text":"Consider the following code: private static int getAnswer ( int a , int b ) { return 2 * a + b ; } The numerical evaluation of the previous sections doesn't get you very far, since the parameters are unknown, so all computations produce unknown values: Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i P1:i [1] iload_0 v0 [0:2] [1:i] P0:i P1:i [2] imul [2:i] P0:i P1:i [3] iload_1 v1 [2:i] [3:i] P0:i P1:i [4] iadd [4:i] P0:i P1:i [5] ireturn P0:i P1:i You can set up symbolic evaluation with an IdentifiedValueFactory: ValueFactory valueFactory = new IdentifiedValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The overall result of the analysis of the sample method is: Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i0 P1:i1 [1] iload_0 v0 [0:2] [1:i0] P0:i0 P1:i1 [2] imul [2:(2*i0)] P0:i0 P1:i1 [3] iload_1 v1 [2:(2*i0)] [3:i1] P0:i0 P1:i1 [4] iadd [4:((2*i0)+i1)] P0:i0 P1:i1 [5] ireturn P0:i0 P1:i1 The unknown values now have symbolic names (IDs): \"i0\" and \"i1\". Any computations result in symbolic expressions, such as \"((2*i0)+i1)\". Useful applications: a basis for symbolic simplification, static single assignment, further analysis with SMT solvers (satisfiability modulo theories).","title":"Symbolic numerical evaluation"},{"location":"analyzing.html#tracing","text":"The previous sections only showed examples with primitive types. Consider the following code with reference types: public static Number getAnswer ( Number answer ) { if ( answer == null ) { answer = new Integer ( 42 ); } return answer ; } The basic or numeric evaluation of the previuous sections don't tell much about the non-primitive types: Instruction Stack v0 [0] aload_0 v0 [0:a] P0:a [1] ifnonnull +13 (target=14) P0:a [4] new #2 [4:a] P0:a [7] dup [4:7:a] [4:7:a] P0:a [8] bipush 42 [4:7:a] [4:7:a] [8:42] P0:a [10] invokespecial #3 [4:7:a] P0:a [13] astore_0 v0 13:a [14] aload_0 v0 [14:a] P0,13:a [15] areturn P0,13:a Unknown reference types are shown as \"a\". You can keep track of origins of references in more detail with a ReferenceTracingValueFactory and a ReferenceTracingInvocationUnit. The PartialEvaluator is set up slightly differently from the earlier examples: ReferenceTracingValueFactory valueFactory = new ReferenceTracingValueFactory ( new BasicValueFactory ()) : InvocationUnit invocationUnit = new ReferenceTracingInvocationUnit ( new BasicInvocationUnit ( valueFactory )); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false , valueFactory ); The results then show the origins of non-primitive types: Instruction Stack v0 [0] aload_0 v0 [0:P0:a] P0:P0:a [1] ifnonnull +13 (target=14) P0:P0:a [4] new #2 [4:N4:a] P0:P0:a [7] dup [4:7:N4:a] [4:7:N4:a] P0:P0:a [8] bipush 42 [4:7:N4:a] [4:7:N4:a] [8:i] P0:P0:a [10] invokespecial #3 [4:7:N4:a] P0:P0:a [13] astore_0 v0 13:N4:a [14] aload_0 v0 [14:N4,P0:a] P0,13:N4,P0:a [15] areturn P0,13:N4,P0:a For example, the method pops and returns either a new instance (\"N4\") that was created at offset 4, or parameter 0 (\"P0\"). Useful applications: define/use analysis, a basis for escape analysis or taint analysis.","title":"Evaluation with reference types"},{"location":"analyzing.html#typed","text":"You can keep track of non-primitive types in more detail with a TypedReferenceValueFactory: ValueFactory valueFactory = new TypedReferenceValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results then show the types: Instruction Stack v0 [0] aload_0 v0 [0:java/lang/Number] P0:java/lang/Number [1] ifnonnull +13 (target=14) P0:java/lang/Number [4] new #2 [4:java/lang/Integer=!] P0:java/lang/Number [7] dup [4:7:java/lang/Integer=!] [4:7:java/lang/Integer=!] P0:java/lang/Number [8] bipush 42 [4:7:java/lang/Integer=!] [4:7:java/lang/Integer=!] [8:i] P0:java/lang/Number [10] invokespecial #3 [4:7:java/lang/Integer=!] P0:java/lang/Number [13] astore_0 v0 13:java/lang/Integer=! [14] aload_0 v0 [14:java/lang/Number] P0,13:java/lang/Number [15] areturn P0,13:java/lang/Number The types here are \"java/lang/Number\" and \"java/lang/Integer\". The types respect the type hierarchy, for example when the branches join and the type is \"java/lang/Number\". A mark \"=\" means that the type is the exact type, not an extension. A mark \"!\" means that the value is definitely not null. Useful applications: preverification of the type safety of bytecode.","title":"Evaluation with more precise reference types"},{"location":"analyzing.html#array","text":"Primitive arrays may be of special interest, for example when performing optimizations. Consider the following code: public static int getAnswer () { int [] array = new int [] { 6 , 7 }; return array [ 0 ] * array [ 1 ] ; } Even though this is a trivial example, the previous evaluations wouldn't provide much useful information: Instruction Stack v0 [0] iconst_2 [0:i] empty [1] newarray 10 [1:[I?=![i]] empty [3] dup [1:3:[I?=![i]] [1:3:[I?=![i]] empty [4] iconst_0 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] empty [5] bipush 6 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] [5:i] empty [7] iastore [1:3:[I?=![i]] empty [8] dup [1:8:[I?=![i]] [1:8:[I?=![i]] empty [9] iconst_1 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] empty [10] bipush 7 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] [10:i] empty [12] iastore [1:8:[I?=![i]] empty [13] astore_0 v0 13:[I?=![i] [14] aload_0 v0 [14:[I?=![i]] 13:[I?=![i] [15] iconst_0 [14:[I?=![i]] [15:i] 13:[I?=![i] [16] iaload [16:i] 13:[I?=![i] [17] aload_0 v0 [16:i] [17:[I?=![i]] 13:[I?=![i] [18] iconst_1 [16:i] [17:[I?=![i]] [18:i] 13:[I?=![i] [19] iaload [16:i] [19:i] 13:[I?=![i] [20] imul [20:i] 13:[I?=![i] [21] ireturn 13:[I?=![i] The array type is \"[I\", which is the standard notation for an array of primitive integers. You can keep track of the lengths of arrays with ArrayReferenceValueFactory and even of the contents of primitive arrays with DetailedArrayValueFactory: ValueFactory valueFactory = new DetailedArrayValueFactory (); InvocationUnit invocationUnit = new BasicInvocationUnit ( valueFactory ); PartialEvaluator partialEvaluator = new PartialEvaluator ( valueFactory , invocationUnit , false ); The results of the evaluation then become: Instruction Stack v0 [0] iconst_2 [0:2] empty [1] newarray 10 [1:[I?=![2]#0 empty [3] dup [1:3:[I?=![2]#0 empty [4] iconst_0 [1:3:[I?=![2]#0 empty [5] bipush 6 [1:3:[I?=![2]#0 empty [7] iastore [1:3:[I?=![2]#0 empty [8] dup [1:8:[I?=![2]#0 empty [9] iconst_1 [1:8:[I?=![2]#0 empty [10] bipush 7 [1:8:[I?=![2]#0 empty [12] iastore [1:8:[I?=![2]#0 empty [13] astore_0 v0 13:[I?=![2]#0 [14] aload_0 v0 [14:[I?=![2]#0 13:[I?=![2]#0 [15] iconst_0 [14:[I?=![2]#0 13:[I?=![2]#0 [16] iaload [16:6] 13:[I?=![2]#0 [17] aload_0 v0 [16:6] [17:[I?=![2]#0 13:[I?=![2]#0 [18] iconst_1 [16:6] [17:[I?=![2]#0 13:[I?=![2]#0 [19] iaload [16:6] [19:7] 13:[I?=![2]#0 [20] imul [20:42] 13:[I?=![2]#0 [21] ireturn 13:[I?=![2]#0 The array is now traced as having length 2 and elements 6 and 7. Useful application: simplification of code with enum types.","title":"Evaluation with primitive arrays"},{"location":"building.html","text":"If you've downloaded the source code of the ProGuardCORE library, you can build it yourself with Gradle: Build the artifacts: ./gradlew assemble Publish the artifacts to your local Maven cache (something like ~/.m2/ ): ./gradlew publishToMavenLocal Build tar and zip archives with the binaries and documentation: ./gradlew distTar distZip Build the complete API documentation with ./gradlew javadoc You can then find the API documentation in docs/md/api .","title":"Building"},{"location":"creating.html","text":"The easiest way to create a new class from scratch is with ClassBuilder. It provides a fluent API to add fields and methods. For example, to create a class that prints out \"Hello, world!\": ProgramClass programClass = new ClassBuilder ( VersionConstants . CLASS_VERSION_1_8 , AccessConstants . PUBLIC , \"HelloWorld\" , ClassConstants . NAME_JAVA_LANG_OBJECT ) . addMethod ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"main\" , \"([Ljava/lang/String;)V\" , 50 , code -> code . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/PrintStream;\" ) . ldc ( \"Hello, world!\" ) . invokevirtual ( \"java/io/PrintStream\" , \"println\" , \"(Ljava/lang/String;)V\" ) . return_ ()) . getProgramClass (); You can also use it to add fields and methods to an existing class: ProgramClass programClass = new ClassBuilder ( existingClass ) ..... Complete example: CreateHelloWorldClass.java","title":"Creating classes"},{"location":"downloads.html","text":"The ProGuardCORE library is distributed under the terms of the Apache License Version 2.0. Please consult the license page for more details. ProGuardCORE is written in Java, so it requires a Java Runtime Environment (JRE 1.8 or higher). You can download the library in various forms: Pre-built artifacts at JCenter dependencies { compile project ( ':com.guardsquare:proguard-core:7.0.1' ) } or <dependency> <groupId> com.guardsquare </groupId> <artifactId> proguard-core </artifactId> <version> 7.0.1 </version> </dependency> or https://jcenter.bintray.com/com/guardsquare/proguard-core/7.0.1/proguard-core-7.0.1.jar Pre-built artifacts at Maven Central A Git repository of the source code at Github git clone https://github.com/Guardsquare/proguard-core.git You can find major releases, minor releases with important bug fixes, and beta releases with the latest new features and any less urgent bug fixes. If you're still working with an older version of the library, check out the release notes , to see if you're missing something essential.","title":"Downloads"},{"location":"editing.html","text":"Editing classes You can edit existing classes with ClassEditor and related editors like InterfacesEditor, AttributesEditor, and ConstantPoolEditor. ClassEditor classEditor = new ClassEditor ( targetClass ); classEditor . addField ( field ); classEditor . addMethod ( method ); If you want to create and add new fields or methods from scratch, you can use the more convenient ClassBuilder: ProgramClass programClass = new ClassBuilder ( existingClass ) . addField ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"someField\" , TypeConstants . INT ); . addMethod ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"main\" , \"([Ljava/lang/String;)V\" , 50 , code -> code . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/PrintStream;\" ) . ldc ( \"Hello, world!\" ) . invokevirtual ( \"java/io/PrintStream\" , \"println\" , \"(Ljava/lang/String;)V\" ) . return_ ()) . getProgramClass (); Editing code Perhaps more interestingly, you can edit the bytecode of method bodies with CodeAttributeEditor. CodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor (); InstructionSequenceBuilder builder = new InstructionSequenceBuilder ( targetClass ); Instructions [] replacementInstructions = builder . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/ .ldc(\" Hello \") .invokevirtual(\" java / io / PrintStream \", \" println \", \" ( Ljava / lang / String ;) V \" . instructions (); // Prepare the editor for this code. codeAttributeEditor . reset ( codeAttribute . u4codeLength ); // Insert the instruction sequence before a specified offset. codeAttributeEditor . insertBeforeOffset ( offset , replacementInstructions ); // Apply the changes. codeAttributeEditor . visitCodeAttribute ( clazz , method , codeAttribute );","title":"Editing classes"},{"location":"editing.html#editing-classes","text":"You can edit existing classes with ClassEditor and related editors like InterfacesEditor, AttributesEditor, and ConstantPoolEditor. ClassEditor classEditor = new ClassEditor ( targetClass ); classEditor . addField ( field ); classEditor . addMethod ( method ); If you want to create and add new fields or methods from scratch, you can use the more convenient ClassBuilder: ProgramClass programClass = new ClassBuilder ( existingClass ) . addField ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"someField\" , TypeConstants . INT ); . addMethod ( AccessConstants . PUBLIC | AccessConstants . STATIC , \"main\" , \"([Ljava/lang/String;)V\" , 50 , code -> code . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/PrintStream;\" ) . ldc ( \"Hello, world!\" ) . invokevirtual ( \"java/io/PrintStream\" , \"println\" , \"(Ljava/lang/String;)V\" ) . return_ ()) . getProgramClass ();","title":"Editing classes"},{"location":"editing.html#editing-code","text":"Perhaps more interestingly, you can edit the bytecode of method bodies with CodeAttributeEditor. CodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor (); InstructionSequenceBuilder builder = new InstructionSequenceBuilder ( targetClass ); Instructions [] replacementInstructions = builder . getstatic ( \"java/lang/System\" , \"out\" , \"Ljava/io/ .ldc(\" Hello \") .invokevirtual(\" java / io / PrintStream \", \" println \", \" ( Ljava / lang / String ;) V \" . instructions (); // Prepare the editor for this code. codeAttributeEditor . reset ( codeAttribute . u4codeLength ); // Insert the instruction sequence before a specified offset. codeAttributeEditor . insertBeforeOffset ( offset , replacementInstructions ); // Apply the changes. codeAttributeEditor . visitCodeAttribute ( clazz , method , codeAttribute );","title":"Editing code"},{"location":"kotlin.html","text":"Kotlin metadata The library makes it easy to read, write and modify the Kotlin metadata that is attached to Java classes. The following example prints all the names of Kotlin functions in the metadata attached to the Java class Foo : programClassPool . classesAccept ( new ClassNameFilter ( \"Foo\" , new ReferencedKotlinMetadataVisitor ( new AllFunctionsVisitor ( ( clazz , container , function ) -> System . out . println ( function . name )))));","title":"Kotlin metadata"},{"location":"kotlin.html#kotlin-metadata","text":"The library makes it easy to read, write and modify the Kotlin metadata that is attached to Java classes. The following example prints all the names of Kotlin functions in the metadata attached to the Java class Foo : programClassPool . classesAccept ( new ClassNameFilter ( \"Foo\" , new ReferencedKotlinMetadataVisitor ( new AllFunctionsVisitor ( ( clazz , container , function ) -> System . out . println ( function . name )))));","title":"Kotlin metadata"},{"location":"license.html","text":"The ProGuardCORE library is licensed under the Apache License Version 2.0. Copyright 2002-2020 Guardsquare NV Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS","title":"License"},{"location":"patternmatching.html","text":"Basic pattern matching The library has powerful support to match patterns in bytecode instruction sequences. You first define the pattern as a sequence of instructions, with wildcards. For example: final int X = InstructionSequenceMatcher . X ; final int C = InstructionSequenceMatcher . C ; InstructionSequenceBuilder ____ = new InstructionSequenceBuilder (); Instruction [] pattern = ____ . iload ( X ) . bipush ( C ) . istore ( X ). __ (); Constant [] constants = ____ . constants (); You can then find that pattern in given code: programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new AllInstructionVisitor ( new MyMatchPrinter ( new InstructionSequenceMatcher ( constants , pattern )))))); Complete example: ApplyPeepholeOptimizations.java Replacing patterns Instead of just matching instruction sequences, you can also replace matched sequences by other instruction sequences, for example to optimize code or instrument code. The core classes are PeepholeEditor and InstructionSequenceReplacer. Say that you want to replace an instruction sequence \"putstatic/getstatic\" by an equivalent \"dup/putstatic\": final int X = InstructionSequenceReplacer . X ; InstructionSequenceBuilder ____ = new InstructionSequenceBuilder (); Instruction [][] replacements = { ____ . putstatic ( X ) . getstatic ( X ). __ (), ____ . dup () . putstatic ( X ). __ () }; Constant [] constants = ____ . constants (); BranchTargetFinder branchTargetFinder = new BranchTargetFinder (); CodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor (); programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new PeepholeEditor ( branchTargetFinder , codeAttributeEditor , new InstructionSequenceReplacer ( constants , replacements , branchTargetFinder , codeAttributeEditor ))))); You can define multiple patterns and their respective replacements in one go, with the wrapper InstructionSequencesReplacer. Complete example: ApplyPeepholeOptimizations.java","title":"Pattern matching"},{"location":"patternmatching.html#basic-pattern-matching","text":"The library has powerful support to match patterns in bytecode instruction sequences. You first define the pattern as a sequence of instructions, with wildcards. For example: final int X = InstructionSequenceMatcher . X ; final int C = InstructionSequenceMatcher . C ; InstructionSequenceBuilder ____ = new InstructionSequenceBuilder (); Instruction [] pattern = ____ . iload ( X ) . bipush ( C ) . istore ( X ). __ (); Constant [] constants = ____ . constants (); You can then find that pattern in given code: programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new AllInstructionVisitor ( new MyMatchPrinter ( new InstructionSequenceMatcher ( constants , pattern )))))); Complete example: ApplyPeepholeOptimizations.java","title":"Basic pattern matching"},{"location":"patternmatching.html#replacing-patterns","text":"Instead of just matching instruction sequences, you can also replace matched sequences by other instruction sequences, for example to optimize code or instrument code. The core classes are PeepholeEditor and InstructionSequenceReplacer. Say that you want to replace an instruction sequence \"putstatic/getstatic\" by an equivalent \"dup/putstatic\": final int X = InstructionSequenceReplacer . X ; InstructionSequenceBuilder ____ = new InstructionSequenceBuilder (); Instruction [][] replacements = { ____ . putstatic ( X ) . getstatic ( X ). __ (), ____ . dup () . putstatic ( X ). __ () }; Constant [] constants = ____ . constants (); BranchTargetFinder branchTargetFinder = new BranchTargetFinder (); CodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor (); programClassPool . classesAccept ( new AllMethodVisitor ( new AllAttributeVisitor ( new PeepholeEditor ( branchTargetFinder , codeAttributeEditor , new InstructionSequenceReplacer ( constants , replacements , branchTargetFinder , codeAttributeEditor ))))); You can define multiple patterns and their respective replacements in one go, with the wrapper InstructionSequencesReplacer. Complete example: ApplyPeepholeOptimizations.java","title":"Replacing patterns"},{"location":"reading.html","text":"Streaming classes from a jar file You can read classes from class files and various types of (nested) jar files or jmod files, with some convenient utility classes and visitors. For example, you can read all classes from all jar files in a given directory and print them out in a streaming fashion, while they are read, without collecting their representations: DataEntrySource source = new DirectorySource ( new File ( inputDirectoryName )); source . pumpDataEntries ( new FilteredDataEntryReader ( new DataEntryNameFilter ( new ExtensionMatcher ( \".jar\" )) new JarReader ( new ClassFilter ( new ClassReader ( false , false , false , false , null , new ClassPrinter ())))); Note the constructor-based dependency injection, to create a chain of visitor classes. We typically use a slightly unconventional indentation to make this construct easy to read. Complete example: PrintClasses.java Writing out streamed classes You can read classes, optionally perform some small modifications, and write them out right away, again in a streaming fashion. JarWriter jarWriter = new JarWriter ( new ZipWriter ( new FixedFileWriter ( new File ( outputJarFileName )))); DataEntrySource source = new FileSource ( new File ( inputJarFileName )); source . pumpDataEntries ( new JarReader ( new ClassFilter ( new ClassReader ( false , false , false , false , null , new DataEntryClassWriter ( jarWriter ))))); jarWriter . close (); Complete example: ApplyPeepholeOptimizations.java Collecting classes Alternatively, you may want to collect the classes in a so-called class pool first, so you can perform more extensive analyses on them: ClassPool classPool = new ClassPool (); DataEntrySource source = new FileSource ( new File ( jarFileName )); source . pumpDataEntries ( new JarReader ( false , new ClassFilter ( new ClassReader ( false , false , false , false , null , new ClassPoolFiller ( classPool ))))); Complete example: Preverify.java Writing out a set of classes If you've collected a set of classes in a class pool, you can write them out with the same visitors as before. JarWriter jarWriter = new JarWriter ( new ZipWriter ( new FixedFileWriter ( new File ( outputJarFileName )))); classPool . classesAccept ( new DataEntryClassWriter ( jarWriter )); jarWriter . close (); Complete example: Preverify.java","title":"Reading classes"},{"location":"reading.html#streaming-classes-from-a-jar-file","text":"You can read classes from class files and various types of (nested) jar files or jmod files, with some convenient utility classes and visitors. For example, you can read all classes from all jar files in a given directory and print them out in a streaming fashion, while they are read, without collecting their representations: DataEntrySource source = new DirectorySource ( new File ( inputDirectoryName )); source . pumpDataEntries ( new FilteredDataEntryReader ( new DataEntryNameFilter ( new ExtensionMatcher ( \".jar\" )) new JarReader ( new ClassFilter ( new ClassReader ( false , false , false , false , null , new ClassPrinter ())))); Note the constructor-based dependency injection, to create a chain of visitor classes. We typically use a slightly unconventional indentation to make this construct easy to read. Complete example: PrintClasses.java","title":"Streaming classes from a jar file"},{"location":"reading.html#writing-out-streamed-classes","text":"You can read classes, optionally perform some small modifications, and write them out right away, again in a streaming fashion. JarWriter jarWriter = new JarWriter ( new ZipWriter ( new FixedFileWriter ( new File ( outputJarFileName )))); DataEntrySource source = new FileSource ( new File ( inputJarFileName )); source . pumpDataEntries ( new JarReader ( new ClassFilter ( new ClassReader ( false , false , false , false , null , new DataEntryClassWriter ( jarWriter ))))); jarWriter . close (); Complete example: ApplyPeepholeOptimizations.java","title":"Writing out streamed classes"},{"location":"reading.html#collecting-classes","text":"Alternatively, you may want to collect the classes in a so-called class pool first, so you can perform more extensive analyses on them: ClassPool classPool = new ClassPool (); DataEntrySource source = new FileSource ( new File ( jarFileName )); source . pumpDataEntries ( new JarReader ( false , new ClassFilter ( new ClassReader ( false , false , false , false , null , new ClassPoolFiller ( classPool ))))); Complete example: Preverify.java","title":"Collecting classes"},{"location":"reading.html#writing-out-a-set-of-classes","text":"If you've collected a set of classes in a class pool, you can write them out with the same visitors as before. JarWriter jarWriter = new JarWriter ( new ZipWriter ( new FixedFileWriter ( new File ( outputJarFileName )))); classPool . classesAccept ( new DataEntryClassWriter ( jarWriter )); jarWriter . close (); Complete example: Preverify.java","title":"Writing out a set of classes"},{"location":"releasenotes.html","text":"Version 7.1 Version Issue Module Explanation 7.1.x PGC-0016 CORE Fixed potential ClassCastException in ConstructorMethodFilter . 7.1.x PGC-0015 CORE Allowing Java 16. 7.1.x PGD-0064 CORE Added support for Java 14 and 15. 7.1.x PGD-0064 CORE Added support for sealed classes (permitted subclasses attributes). 7.1.x PGD-0064 CORE Added support for record attributes. 7.1.x CORE Fixed potential NullPointerException for module classes in ClassPrinter. 7.1.x PGD-5 CORE Improved efficiency of building classes, methods and constant pools. 7.1.x DGD-2390 CORE Fixed storage and alignment of uncompressed zip entries. 7.1.x DGD-2338 CORE Fixed processing of constant boolean arrays. 7.1.x CORE Fixed adding branch instructions with labels in CompactCodeAttributeComposer. 7.1.x CORE Added missing dimensions argument to CompactCodeAttributeComposer.multianewarray. Version 7.0 (Jan 2020) Version Issue Module Explanation 7.0.1 DGD-2382 CORE Fixed processing of Kotlin 1.4 metadata annotations. 7.0.1 DGD-2390 CORE Fixed storage and alignment of uncompressed zip entries. 7.0.1 DGD-2338 CORE Fixed processing of constant boolean arrays. 7.0.1 CORE Fixed adding branch instructions with labels in CompactCodeAttributeComposer. 7.0.0 CORE Initial release of Kotlin support. 7.0.0 PGD-32 CORE Allowing Java 14 class files. 7.0.0 DGD-1780 CORE Removed dependency on internal sun.security API. 7.0.0 DGD-1800 CORE Fixed obfuscation of functional interfaces with abstract Object methods. 7.0.0 CORE Initial release, extracted from ProGuard.","title":"Release notes"},{"location":"releasenotes.html#version-71","text":"Version Issue Module Explanation 7.1.x PGC-0016 CORE Fixed potential ClassCastException in ConstructorMethodFilter . 7.1.x PGC-0015 CORE Allowing Java 16. 7.1.x PGD-0064 CORE Added support for Java 14 and 15. 7.1.x PGD-0064 CORE Added support for sealed classes (permitted subclasses attributes). 7.1.x PGD-0064 CORE Added support for record attributes. 7.1.x CORE Fixed potential NullPointerException for module classes in ClassPrinter. 7.1.x PGD-5 CORE Improved efficiency of building classes, methods and constant pools. 7.1.x DGD-2390 CORE Fixed storage and alignment of uncompressed zip entries. 7.1.x DGD-2338 CORE Fixed processing of constant boolean arrays. 7.1.x CORE Fixed adding branch instructions with labels in CompactCodeAttributeComposer. 7.1.x CORE Added missing dimensions argument to CompactCodeAttributeComposer.multianewarray.","title":"Version 7.1"},{"location":"releasenotes.html#version-70-jan-2020","text":"Version Issue Module Explanation 7.0.1 DGD-2382 CORE Fixed processing of Kotlin 1.4 metadata annotations. 7.0.1 DGD-2390 CORE Fixed storage and alignment of uncompressed zip entries. 7.0.1 DGD-2338 CORE Fixed processing of constant boolean arrays. 7.0.1 CORE Fixed adding branch instructions with labels in CompactCodeAttributeComposer. 7.0.0 CORE Initial release of Kotlin support. 7.0.0 PGD-32 CORE Allowing Java 14 class files. 7.0.0 DGD-1780 CORE Removed dependency on internal sun.security API. 7.0.0 DGD-1800 CORE Fixed obfuscation of functional interfaces with abstract Object methods. 7.0.0 CORE Initial release, extracted from ProGuard.","title":"Version 7.0 (Jan 2020)"}]}